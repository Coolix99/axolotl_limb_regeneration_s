import numpy as np
import skimage.morphology
from scipy import ndimage
import copy

def change_bitdepth_uint16_to_uint8(image):
    """
    Convert an image from 16-bit depth to 8-bit depth.

    Parameters
    ----------
    image : np.array
        Input image with 16-bit pixel depth.

    Returns
    -------
    image_new : np.array
        Output image with 8-bit pixel depth.
    """
    # Divide each pixel value by 256 and cast to 8-bit unsigned integer
    return (image // 256).astype(np.uint8)

def invert(mask):
    """
    Invert a binary mask.

    Parameters
    ----------
    mask : np.array
        Input binary mask as a NumPy array.

    Returns
    -------
    np.array
        Inverted binary mask as a 16-bit unsigned integer array.
    """
    # Convert mask to boolean, invert values (0 -> 1, 1 -> 0), and cast to uint16
    return np.abs(mask.astype(bool) - 1).astype(np.uint16)

def subtract_bg_clip(image, mask, mask_for_bg=None):
    """
    Subtract the mean background value outside the mask from the image and clip the image using the mask.

    Parameters
    ----------
    image : np.array
        Input image as a NumPy array.
    mask : np.array
        Binary mask to define the region of interest.
    mask_for_bg : np.array, optional
        Binary mask for background subtraction (if different from `mask`).

    Returns
    -------
    np.array
        Image with background subtracted and clipped, as a 16-bit unsigned integer array.
    """
    if not isinstance(mask_for_bg, np.ndarray):
        # Use the inverse of the provided mask for background calculation
        mask_inverted = invert(mask)
        bg = mask_inverted * image
        if np.any(bg != 0):
            bg = np.mean(bg[np.where(bg != 0)])
        else:
            bg = 0
        print(f'Mean background value = {bg}')
        
        # Subtract background and clip the image using the mask
        image_wo_bg = (image - bg) * mask
        image_wo_bg[np.where(image < bg)] = 0
        return image_wo_bg.astype(np.uint16)
    else:
        # If a separate mask is provided for background subtraction
        print('Masks for clipping and background subtraction are different.')
        mask_inverted = invert(mask_for_bg)
        bg = mask_inverted * image
        if np.any(bg != 0):
            bg = np.mean(bg[np.where(bg != 0)])
        else:
            bg = 0
        print(f'Mean background value = {bg}')
        
        # Subtract background and clip the image using the mask
        image_wo_bg = (image - bg) * mask
        image_wo_bg[np.where(image < bg)] = 0
        return image_wo_bg.astype(np.uint16)

def morph_change(mask, r, fill_holes):
    """
    Apply morphological operations to the given mask:
    1. Optionally fill binary holes.
    2. Apply binary opening.
    3. Apply binary closing.

    Parameters
    ----------
    mask : np.array
        Input binary mask as a NumPy array.
    r : int
        Radius for the structuring element used in morphological operations.
    fill_holes : bool
        Whether to fill holes in the mask.

    Returns
    -------
    mask : np.array
        Modified binary mask after morphological operations.
    """
    # Create a disk-shaped structuring element for morphological operations
    selem = skimage.morphology.disk(radius=r)
    
    # Process each slice of the mask
    for j, i in enumerate(mask):
        if fill_holes:
            # Fill holes in the first channel and the mask slice
            i[0, :] = ndimage.binary_fill_holes(i[0, :])
            mask[j, :, :] = ndimage.binary_fill_holes(i)
        
        # Apply binary opening
        i = skimage.morphology.binary_opening(i, selem)
        
        # Apply binary closing
        mask[j, :, :] = skimage.morphology.binary_closing(i, selem)
    
    return mask

def shift_array_with_zeros(arr, shift_amount, axis):
    """
    Shift an array along a specified axis, filling the vacated positions with zeros. 
    Generated by ChatGPT. 

    Parameters
    ----------
    arr : np.array
        Input array to be shifted.
    shift_amount : int
        Number of positions to shift. Positive values shift to the right, negative values to the left.
    axis : int
        Axis along which the array is shifted.

    Returns
    -------
    np.array
        Shifted array with zeros in the vacated positions.
    """
    # Get the shape of the input array
    shape = arr.shape

    # Initialize a new array filled with zeros
    shifted_array = np.zeros_like(arr)

    # Create index slices for advanced indexing
    index = [slice(None)] * len(shape)
    shifted_index = [slice(None)] * len(shape)

    if shift_amount >= 0:
        # Shift to the right
        index[axis] = slice(shift_amount, None)
        shifted_index[axis] = slice(None, -shift_amount)
    else:
        # Shift to the left
        index[axis] = slice(None, shift_amount)
        shifted_index[axis] = slice(-shift_amount, None)

    # Copy the shifted values into the new array
    shifted_array[tuple(index)] = arr[tuple(shifted_index)]

    return shifted_array

def epiderm(tissue_mask, r, extend_along_z=False, extend_along_y=False, extend_along_x=False):
    """
    Naively exclude the epidermis by removing `r` pixels from the mask surface along specified axes.

    Parameters
    ----------
    tissue_mask : np.array
        Input binary mask representing the tissue.
    r : int
        Number of pixels to exclude at the mask surface.
    extend_along_z : bool, optional
        If True, extend the mask along the z-axis. Default is False.
    extend_along_y : bool, optional
        If True, extend the mask along the y-axis. Default is False.
    extend_along_x : bool, optional
        If True, extend the mask along the x-axis. Default is False.

    Returns
    -------
    mask_derm : np.array
        Mask with the epidermis excluded, as a 16-bit unsigned integer array.
    """
    # Extend the mask along specified axes
    if extend_along_z and not extend_along_y and not extend_along_x:
        k, j, i = tissue_mask.shape
        tissue_mask_new = np.zeros([k + 2 * r, j, i])
        tissue_mask_new[r:-r, :, :] = tissue_mask
        tissue_mask_new[:r, :, :] = tissue_mask[0, :, :]
        tissue_mask_new[-r:, :, :] = tissue_mask[-1, :, :]
        tissue_mask = tissue_mask_new
        mask_img_rect = np.zeros_like(tissue_mask)
        mask_img_rect[r:-r, r:-r, r:-r] = 1

    elif extend_along_y and not extend_along_z and not extend_along_x:
        k, j, i = tissue_mask.shape
        tissue_mask_new = np.zeros([k, j + 2 * r, i])
        tissue_mask_new[:, r:-r, :] = tissue_mask
        tissue_mask_new[:, :r, :] = tissue_mask[:, :1, :]
        tissue_mask_new[:, -r:, :] = tissue_mask[:, -1:, :]
        tissue_mask = tissue_mask_new
        mask_img_rect = np.zeros_like(tissue_mask)
        mask_img_rect[r:-r, r:-r, r:-r] = 1

    elif extend_along_z and extend_along_y and not extend_along_x:
        k, j, i = tissue_mask.shape
        tissue_mask_new = np.zeros([k + 2 * r, j + 2 * r, i])
        tissue_mask_new[r:-r, r:-r, :] = tissue_mask
        tissue_mask_new[:r, r:-r, :] = tissue_mask[0, :, :]
        tissue_mask_new[-r:, r:-r, :] = tissue_mask[-1, :, :]
        tissue_mask_new[:, :r, :] = tissue_mask_new[:, r:r+1, :]
        tissue_mask_new[:, -r:, :] = tissue_mask_new[:, -r-1:-r, :]
        tissue_mask = tissue_mask_new
        mask_img_rect = np.zeros_like(tissue_mask)
        mask_img_rect[r:-r, r:-r, r:-r] = 1

    elif extend_along_z and extend_along_y and extend_along_x:
        k, j, i = tissue_mask.shape
        tissue_mask_new = np.zeros([k + 2 * r, j + 2 * r, i + 2 * r])
        tissue_mask_new[r:-r, r:-r, r:-r] = tissue_mask
        tissue_mask_new[:r, r:-r, r:-r] = tissue_mask[0, :, :]
        tissue_mask_new[-r:, r:-r, r:-r] = tissue_mask[-1, :, :]
        tissue_mask_new[:, :r, r:-r] = tissue_mask_new[:, r:r+1, r:-r]
        tissue_mask_new[:, -r:, r:-r] = tissue_mask_new[:, -r-1:-r, r:-r]
        tissue_mask_new[:, r:-r, :r] = tissue_mask_new[:, r:-r, r:r+1]
        tissue_mask_new[:, r:-r, -r:] = tissue_mask_new[:, r:-r, -r-1:-r]
        tissue_mask = tissue_mask_new
        mask_img_rect = np.zeros_like(tissue_mask)
        mask_img_rect[r:-r, r:-r, r:-r] = 1

    else:
        mask_img_rect = np.zeros_like(tissue_mask)
        mask_img_rect[r:-r, r:-r, r:-r] = 1

    # Convert tissue mask to uint8
    tissue_mask = tissue_mask.astype(np.uint8)

    # Compute derivatives along each axis
    mask_x = ((shift_array_with_zeros(tissue_mask, -r, axis=2) + 
               shift_array_with_zeros(tissue_mask, r, axis=2) - 
               2 * tissue_mask) * tissue_mask)
    mask_y = ((shift_array_with_zeros(tissue_mask, -r, axis=1) + 
               shift_array_with_zeros(tissue_mask, r, axis=1) - 
               2 * tissue_mask) * tissue_mask)
    mask_z = ((shift_array_with_zeros(tissue_mask, -r, axis=0) + 
               shift_array_with_zeros(tissue_mask, r, axis=0) - 
               2 * tissue_mask) * tissue_mask)

    # Combine masks to identify the dermis region
    mask_derm = ((mask_x + mask_y + mask_z) > 0).astype(np.uint16)

    # Remove extended regions if applicable
    if extend_along_z and not extend_along_y and not extend_along_x:
        mask_derm = mask_derm * mask_img_rect
        return mask_derm[r:-r, :, :]
    elif extend_along_y and not extend_along_z and not extend_along_x:
        mask_derm = mask_derm * mask_img_rect
        return mask_derm[:, r:-r, :]
    elif extend_along_z and extend_along_y and not extend_along_x:
        mask_derm = mask_derm * mask_img_rect
        return mask_derm[r:-r, r:-r, :]
    elif extend_along_z and extend_along_y and extend_along_x:
        mask_derm = mask_derm * mask_img_rect
        return mask_derm[r:-r, r:-r, r:-r]
    else:
        return mask_derm * mask_img_rect   

def crop(image, mask):
    """
    Crop an image or a dictionary of images based on the boundaries defined by a mask.

    Parameters
    ----------
    image : np.array or dict
        Input image (NumPy array) or dictionary of NumPy arrays to crop.
    mask : np.array
        Binary mask used to define the cropping boundaries.

    Returns
    -------
    np.array or dict
        Cropped image(s) as a NumPy array or dictionary of arrays.
    """
    if isinstance(image, dict):
        # Handle case where the input is a dictionary of images
        if mask.ndim == 3:
            #print('Dictionary with 3D data')
            k, i, j = np.nonzero(mask)
            kmin, kmax = max(np.min(k) - 2, 0), np.max(k) + 2
            imin, imax = max(np.min(i) - 2, 0), np.max(i) + 2
            jmin, jmax = max(np.min(j) - 2, 0), np.max(j) + 2
            for key in image.keys():
                if isinstance(image[key], np.ndarray):
                    image[key] = image[key][kmin:kmax, imin:imax, jmin:jmax]
            return image

        elif mask.ndim == 2:
            #print('Dictionary with 2D data')
            k, i = np.nonzero(mask)
            kmin, kmax = np.min(k), np.max(k)
            imin, imax = np.min(i), np.max(i)
            for key in image.keys():
                if isinstance(image[key], np.ndarray):
                    image[key] = image[key][kmin:kmax, imin:imax]
            return image

        elif mask.ndim == 1:
            print('Dictionary with 1D data')
            k = np.nonzero(mask)[0]
            kmin, kmax = np.min(k), np.max(k)
            for key in image.keys():
                if isinstance(image[key], np.ndarray):
                    image[key] = image[key][kmin:kmax]
            return image

    else:
        # Handle case where the input is a single image array
        if image.ndim == 3:
            k, i, j = np.nonzero(mask)
            kmin, kmax = np.min(k), np.max(k)
            imin, imax = np.min(i), np.max(i)
            jmin, jmax = np.min(j), np.max(j)
            return image[kmin:kmax, imin:imax, jmin:jmax]

        elif image.ndim == 2:
            k, i = np.nonzero(mask)
            kmin, kmax = np.min(k), np.max(k)
            imin, imax = np.min(i), np.max(i)

def largest_component(mask):
    """
    Extract the largest connected component from a binary mask.

    Parameters
    ----------
    mask : np.array
        Binary mask where connected components are identified.

    Returns
    -------
    largest_component : np.array
        Binary mask of the largest connected component.
    """
    from scipy.ndimage import label, sum

    # Label connected components in the mask
    labeled_array, num_features = label(mask)

    # Calculate the size of each connected component
    sizes = sum(mask, labeled_array, range(num_features + 1))

    # Identify the label of the largest component
    max_label = sizes.argmax()

    # Create a mask for the largest component
    largest_component = labeled_array == max_label

    return largest_component.astype(int)

def few_largest_components(mask, few):
    """
    Extract the specified number of largest connected components from a binary mask.

    Parameters
    ----------
    mask : np.array
        Binary mask where connected components are identified.
    few : int
        Number of largest connected components to extract.

    Returns
    -------
    largest_components_array : np.array
        Binary mask containing the specified number of largest connected components.
    """
    from scipy.ndimage import label, sum

    # Label connected components in the mask
    labeled_array, num_features = label(mask)

    # Calculate the size of each connected component
    sizes = sum(mask, labeled_array, range(num_features + 1))

    # Identify the labels of the largest components
    max_labels = sizes.argsort()[-few:]  # Indices of the largest components

    # Initialize an array for the largest components
    largest_components_array = np.zeros_like(mask)

    # Add each of the largest components to the output array
    for label_id in max_labels:
        largest_components_array[labeled_array == label_id] = mask[labeled_array == label_id]

    return (largest_components_array > 0).astype(np.uint16)

def gfilter(image, sigma):
    """
    Apply a Gaussian filter to an image, handling zero-valued pixels as NaNs.

    Parameters
    ----------
    image : np.array
        Input image to be filtered.
    sigma : float or sequence of floats
        Standard deviation for Gaussian kernel. Can be a single value or a sequence for each axis.

    Returns
    -------
    image_filtered : np.array
        Filtered image after applying the Gaussian filter.
    """
    from scipy.ndimage import gaussian_filter

    # Convert the image to float for processing
    image_filtered = np.array(image).astype(float)

    # Treat zero-valued pixels as NaNs
    image_filtered[image_filtered == 0] = np.nan

    # Replace NaNs with the mean of non-NaN pixels
    mean_outside = np.nanmean(image_filtered)
    image_filtered[np.isnan(image_filtered)] = mean_outside

    # Apply Gaussian filter with the specified sigma and reflection mode
    image_filtered = gaussian_filter(image_filtered, sigma=sigma, mode='reflect')

    return image_filtered

def relative_dynamic_range(image):
    """
    Calculate the relative dynamic range of an image.

    Parameters
    ----------
    image : np.array
        Input image as a NumPy array.

    Returns
    -------
    float
        Relative dynamic range, calculated as (max - min) / max.
    """
    # Convert the image to float for accurate calculations
    image = image.astype(float)

    # Treat zero-valued pixels as NaNs
    image[image == 0] = np.nan

    # Calculate the maximum and minimum intensity values, ignoring NaNs
    max_intensity = np.nanmax(image)
    min_intensity = np.nanmin(image)

    # Calculate and return the relative dynamic range
    return (max_intensity - min_intensity) / max_intensity

def minmaxnorm(image):
    image = image.astype(float)
    image[image == 0] = np.nan
    max_intensity = np.nanmax(image)
    min_intensity = np.nanmin(image)
    image = (image - min_intensity) / (max_intensity - min_intensity)
    image[np.isnan(image)] = 0

    print(f'relative dynamic range, (max - min)/max = { (max_intensity - min_intensity)/max_intensity }')

    return image

def minmaxnorm(image):
    """
    Normalize an image to the range [0, 1] using min-max normalization, 
    while treating zero-valued pixels as NaNs.

    Parameters
    ----------
    image : np.array
        Input image as a NumPy array.

    Returns
    -------
    np.array
        Min-max normalized image with values in the range [0, 1].
    """
    # Convert the image to float for accurate calculations
    image = image.astype(float)

    # Treat zero-valued pixels as NaNs
    image[image == 0] = np.nan

    # Calculate the maximum and minimum intensity values, ignoring NaNs
    max_intensity = np.nanmax(image)
    min_intensity = np.nanmin(image)

    # Apply min-max normalization
    image = (image - min_intensity) / (max_intensity - min_intensity)

    # Replace NaNs with 0 after normalization
    image[np.isnan(image)] = 0

    # Print the relative dynamic range for reference
    print(f'Relative dynamic range, (max - min)/max = {(max_intensity - min_intensity) / max_intensity}')

    return image

if __name__ == '__main__':
    pass    